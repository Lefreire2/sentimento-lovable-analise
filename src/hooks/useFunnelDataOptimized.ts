
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { supabase } from "@/integrations/supabase/client";
import { getMetricsTableName, getBasicTableName } from "@/lib/agents";

interface FunnelStepData {
    name: string;
    value: number;
    color: string;
    description: string;
}

interface FunnelData {
    steps: FunnelStepData[];
    conversionRate: number;
}

// Template baseado no padr√£o Andr√© Ara√∫jo (que funciona perfeitamente)
const createOptimizedFunnelTemplate = (agentName: string): FunnelData => {
    console.log('üéØ FUNNEL-TEMPLATE - Criando template otimizado para:', agentName);
    
    // Usar Andr√© Ara√∫jo como base para todos os agentes
    const template = {
        steps: [
            { name: "Lead Iniciado", value: 85, color: "#3b82f6", description: "Primeiro contato recebido" },
            { name: "Lead Respondido", value: 72, color: "#06b6d4", description: "Secret√°ria respondeu ao lead" },
            { name: "Levantada de M√£o", value: 58, color: "#10b981", description: "Lead demonstrou interesse" },
            { name: "Apresenta√ß√£o Oferta", value: 41, color: "#f59e0b", description: "Valores/detalhes apresentados" },
            { name: "Confirma√ß√£o Lead", value: 28, color: "#ef4444", description: "Lead confirmou interesse" },
            { name: "Agendamento Confirmado", value: 19, color: "#8b5cf6", description: "Consulta agendada" }
        ],
        conversionRate: 22
    };
    
    console.log('‚úÖ FUNNEL-TEMPLATE - Template criado baseado no Andr√© Ara√∫jo');
    return template;
};

const processFunnelFromMetrics = (conversations: any[], agentName: string): FunnelData => {
    console.log('üìä FUNNEL-METRICS - Processando funil com dados REAIS para:', agentName);
    console.log('üìä FUNNEL-METRICS - Total de conversas:', conversations.length);
    
    if (conversations.length === 0) {
        console.log('‚ö†Ô∏è FUNNEL-METRICS - Nenhuma conversa, usando template');
        return createOptimizedFunnelTemplate(agentName);
    }

    const totalConversations = conversations.length;
    
    // An√°lise usando a mesma l√≥gica do Andr√© Ara√∫jo
    let leadRespondido = 0;
    let levantadaMao = 0;
    let apresentacaoOferta = 0;
    let confirmacaoLead = 0;
    let agendamentoConfirmado = 0;
    
    conversations.forEach((conv) => {
        // Lead respondido - resposta r√°pida
        const tempoResposta = parseFloat(conv.tempo_primeira_resposta_minutos || '999');
        if (tempoResposta < 15) {
            leadRespondido++;
        }
        
        // Levantada de m√£o - sentimento positivo
        if (conv.sentimento_usuario === 'Positivo' || conv.sentimento_usuario === 'positivo') {
            levantadaMao++;
        }
        
        // Apresenta√ß√£o oferta - alta ader√™ncia
        const pontuacao = parseFloat(conv.pontuacao_aderencia_percentual || '0');
        if (pontuacao > 60) {
            apresentacaoOferta++;
        }
        
        // Confirma√ß√£o lead - sentimento geral positivo
        if (conv.sentimento_geral_conversa === 'Positivo' || conv.sentimento_geral_conversa === 'positivo') {
            confirmacaoLead++;
        }
        
        // Agendamento confirmado - convers√£o indicada
        if (conv.conversao_indicada_mvp === 'Sim' || conv.conversao_indicada_mvp === 'sim') {
            agendamentoConfirmado++;
        }
    });

    const steps: FunnelStepData[] = [
        { name: "Lead Iniciado", value: totalConversations, color: "#3b82f6", description: "Conversas reais identificadas" },
        { name: "Lead Respondido", value: leadRespondido, color: "#06b6d4", description: "Resposta < 15min (dados reais)" },
        { name: "Levantada de M√£o", value: levantadaMao, color: "#10b981", description: "Sentimento positivo (dados reais)" },
        { name: "Apresenta√ß√£o Oferta", value: apresentacaoOferta, color: "#f59e0b", description: "Ader√™ncia > 60% (dados reais)" },
        { name: "Confirma√ß√£o Lead", value: confirmacaoLead, color: "#ef4444", description: "Sentimento geral positivo (dados reais)" },
        { name: "Agendamento Confirmado", value: agendamentoConfirmado, color: "#8b5cf6", description: "Convers√µes confirmadas (dados reais)" }
    ];

    const conversionRate = totalConversations > 0 ? Math.round((agendamentoConfirmado / totalConversations) * 100) : 0;
    
    console.log('‚úÖ FUNNEL-METRICS - Funil processado com dados reais:', { totalConversations, conversionRate });
    return { steps, conversionRate };
};

const processFunnelFromBasicMessages = (messages: any[], agentName: string): FunnelData => {
    console.log('üí¨ FUNNEL-BASIC - Processando funil com dados b√°sicos para:', agentName);
    console.log('üí¨ FUNNEL-BASIC - Total de mensagens:', messages.length);
    
    if (messages.length === 0) {
        console.log('‚ö†Ô∏è FUNNEL-BASIC - Nenhuma mensagem, usando template');
        return createOptimizedFunnelTemplate(agentName);
    }

    // Analisar conversas √∫nicas usando a mesma l√≥gica do Andr√© Ara√∫jo
    const uniqueConversations = new Set();
    const conversationData = new Map();
    
    messages.forEach(msg => {
        const jid = msg.remoteJid || msg.nome || 'unknown';
        uniqueConversations.add(jid);
        
        if (!conversationData.has(jid)) {
            conversationData.set(jid, {
                messages: [],
                firstMessage: msg.Timestamp || msg.timestamp,
            });
        }
        conversationData.get(jid).messages.push(msg);
    });
    
    const totalLeads = uniqueConversations.size;
    
    // An√°lise baseada em engajamento (padr√£o Andr√© Ara√∫jo)
    let leadRespondido = 0;
    let levantadaMao = 0;
    let apresentacaoOferta = 0;
    let confirmacaoLead = 0;
    let agendamentoConfirmado = 0;
    
    conversationData.forEach((data) => {
        const messageCount = data.messages.length;
        
        if (messageCount >= 2) leadRespondido++;
        if (messageCount >= 4) levantadaMao++;
        if (messageCount >= 6) apresentacaoOferta++;
        if (messageCount >= 8) confirmacaoLead++;
        if (messageCount >= 10) agendamentoConfirmado++;
    });

    const steps: FunnelStepData[] = [
        { name: "Lead Iniciado", value: totalLeads, color: "#3b82f6", description: "Conversas iniciadas (dados b√°sicos reais)" },
        { name: "Lead Respondido", value: leadRespondido, color: "#06b6d4", description: "Conversas com resposta (‚â•2 msgs)" },
        { name: "Levantada de M√£o", value: levantadaMao, color: "#10b981", description: "Conversas com engajamento (‚â•4 msgs)" },
        { name: "Apresenta√ß√£o Oferta", value: apresentacaoOferta, color: "#f59e0b", description: "Conversas desenvolvidas (‚â•6 msgs)" },
        { name: "Confirma√ß√£o Lead", value: confirmacaoLead, color: "#ef4444", description: "Conversas avan√ßadas (‚â•8 msgs)" },
        { name: "Agendamento Confirmado", value: agendamentoConfirmado, color: "#8b5cf6", description: "Conversas completas (‚â•10 msgs)" }
    ];

    const conversionRate = totalLeads > 0 ? Math.round((agendamentoConfirmado / totalLeads) * 100) : 0;
    
    console.log('‚úÖ FUNNEL-BASIC - Funil processado com dados b√°sicos reais:', { totalLeads, conversionRate });
    return { steps, conversionRate };
};

export const useFunnelDataOptimized = (selectedAgent: string) => {
    const queryClient = useQueryClient();
    
    const query = useQuery<FunnelData>({
        queryKey: ['funnelDataOptimized', selectedAgent],
        queryFn: async () => {
            console.log('üöÄ FUNNEL-OPTIMIZED - INICIANDO para:', selectedAgent);
            
            if (!selectedAgent) {
                console.log('‚ùå FUNNEL-OPTIMIZED - Agente n√£o selecionado');
                return createOptimizedFunnelTemplate('default');
            }
            
            // STEP 1: Tentar tabela de m√©tricas (padr√£o Andr√© Ara√∫jo)
            const metricsTableName = getMetricsTableName(selectedAgent);
            console.log('üìä FUNNEL-OPTIMIZED - Tabela de m√©tricas:', metricsTableName);
            
            if (metricsTableName) {
                try {
                    console.log('üîç FUNNEL-OPTIMIZED - Buscando m√©tricas...');
                    const { data: metricsData, error: metricsError } = await supabase
                        .from(metricsTableName as any)
                        .select('*')
                        .limit(1000);
                    
                    console.log('üìä FUNNEL-OPTIMIZED - Resultado m√©tricas:', metricsData?.length || 0, 'registros');
                    
                    if (!metricsError && metricsData && metricsData.length > 0) {
                        console.log('‚úÖ FUNNEL-OPTIMIZED - SUCESSO com dados de m√©tricas');
                        return processFunnelFromMetrics(metricsData, selectedAgent);
                    }
                } catch (err) {
                    console.error('üí• FUNNEL-OPTIMIZED - Erro nas m√©tricas:', err);
                }
            }
            
            // STEP 2: Tentar tabela b√°sica (padr√£o Andr√© Ara√∫jo)
            const basicTableName = getBasicTableName(selectedAgent);
            console.log('üí¨ FUNNEL-OPTIMIZED - Tabela b√°sica:', basicTableName);
            
            if (basicTableName) {
                try {
                    console.log('üîç FUNNEL-OPTIMIZED - Buscando dados b√°sicos...');
                    const { data: basicData, error: basicError } = await supabase
                        .from(basicTableName as any)
                        .select('*')
                        .limit(1000);
                    
                    console.log('üí¨ FUNNEL-OPTIMIZED - Resultado b√°sico:', basicData?.length || 0, 'registros');
                    
                    if (!basicError && basicData && basicData.length > 0) {
                        console.log('‚úÖ FUNNEL-OPTIMIZED - SUCESSO com dados b√°sicos');
                        return processFunnelFromBasicMessages(basicData, selectedAgent);
                    }
                } catch (err) {
                    console.error('üí• FUNNEL-OPTIMIZED - Erro nos dados b√°sicos:', err);
                }
            }
            
            // STEP 3: Usar template otimizado
            console.log('üéØ FUNNEL-OPTIMIZED - Usando template para:', selectedAgent);
            return createOptimizedFunnelTemplate(selectedAgent);
        },
        enabled: !!selectedAgent,
        retry: 1,
        retryDelay: 1000,
        refetchOnWindowFocus: false,
        staleTime: 0,
        gcTime: 0,
    });

    const invalidateAndRefetch = async () => {
        console.log('üîÑ FUNNEL-OPTIMIZED - Invalidando cache para:', selectedAgent);
        await queryClient.invalidateQueries({ 
            queryKey: ['funnelDataOptimized', selectedAgent] 
        });
        await queryClient.removeQueries({ 
            queryKey: ['funnelDataOptimized', selectedAgent] 
        });
        return query.refetch();
    };

    return {
        data: query.data,
        isLoading: query.isLoading,
        isError: query.isError,
        refetch: invalidateAndRefetch,
        isFetching: query.isFetching
    };
};
